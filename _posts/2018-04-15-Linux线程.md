---
layout:     post
title:      Linux线程
subtitle:   
date:       2018-04-15
author:     LJ
header-img: 
catalog: true
tags:
    - Linux
    - C语言
---

>2018-04-15
>头文件`pthread.h`  

## **1.数据结构**
`pthread_t`线程ID  
`pthread_attr_t`线程属性  

## **2.线程操作**

---

```
pthread_t pthread_self();
```
获取本线程ID 

---

```
int pthread_equal(
    pthread_t tid1,
    pthread_t tid2);
```
比较两个线程ID是否相等
* 相等返回1，不等返回0
* 第一个参数返回创建出的线程的ID  

---

## **3.线程创建**

---

```
int pthread_create(
    pthread_t* restrict tidp,
    const pthread_attr_t* restrict attr,
    void* (*start_rtn)(void*),
    void* restrict arg);
```
创建线程  
* 第一个参数返回创建出的线程的ID  
* 第二个参数指定线程的属性，可以为NULL  
* 第三个参数为线程函数，函数的返回值和参数均为void*  
* 第四个参数为传入线程函数的参数  
* 返回错误值，0为创建成功
* 注：restrict(`__restrict`)
是C语言的类型限定符，用于表明该指针是访问一个数据对象的唯一且初始的方式，便于编译器优化

---

## **4.线程退出**

---

线程一直执行到return语句，并退出

---

```
void pthread_exit(void* rval_ptr);
```
在线程内部调用让线程退出
* 参数为线程退出所返回的值，注意，不要返回线程中栈区数据

---

```
void pthread_cancel(pthread_t tid);
```
指定线程退出
* 参数为想要退出的线程ID
* 注：如同调用了pthread_exit，但指定线程可以选择忽略或者进行自己的处理，只是发送了cancel请求

---

```
int pthread_join(pthread_t tid, void** rval_ptr);
```
在线程中让指定线程运行完毕并返回结果，再继续自己的线程
* 第一个参数为想要加入的线程ID
* 第二个参数为返回的结果，不需要结果可以传入NULL
* 返回值为错误码，0为正确
* 注：两个线程不可以join同一个线程

---

```
void pthread_cleanup_push(void(*rtn)(void*), void* arg);
void pthread_cleanup_pop(int execute);
```
两个函数维护一个函数指针的Stack，可以把函数指针和函数参数值push／pop。
* 当调用pthread_exit,cancel请求以及以非0参数调用pthread_cleanup_pop时，会调用栈中函数
* 注：这两个函数中有宏定义，必须在同一个作用域中出现，否则提示缺少`}`,一般情况下用于处理意外情况

---

```
int pthread_detach(pthread_t tid);
```
使joinable线程进入detached状态
* 当线程为joinable时（缺省情况下），线程的退出状态被保存下来，资源没有完全回收，等待其他线程调用pthread_join才能收回，而处于detached状态时，线程退出则其资源立即被回收
* 注：detached状态无法join

---

## **5.线程同步**



## **死锁**

* 死锁产生的四个必要条件
	* 互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
	* 不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
	* 请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
	* 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所申请地资源。 
* 避免死锁的技术
	* 加锁顺序：线程按照一定的顺序加锁，但需要事先知道所有可能会用到的锁，并对这些锁做适当的排序。
	* 加锁时限：线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁。注意：超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题。
	* 死锁检测：主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。




